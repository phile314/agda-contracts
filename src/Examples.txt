-- first question: We need a more precise type. Nat is not good enough.
-- Could be either Int, Integer, Long and so on.
--
-- We could adapt the idris FFI style for this?
-- Much more complicated will be datatypes.
--
-- We can use the mkForeign idris approach, and later on add
-- syntactic sugar if necessary. That sounds like a reasonable plan?

-- Idris FFI example
-- foo : Int -> IO Int
-- foo x = mkForeign (FFun "foo" [FInt] FInt) x


gcd : (x y : Nat) -> (| z : Nat | z divides x && z divides y |)


map : {A B : Set} -> (f : A -> B) -> (xs : List A) -> (| ys : List B | length xs == length ys &&
    forall i . i > 0 && i < length xs ==> ys !! i == f (xs !! i) |)


getLine : (| x : IO String | not ('\n' elem x ) |)
getLine = mkForeign (HSFun "UHC.Base.getLine" [] (HSIO HSString))

sum : (xs : List Nat) -> (| r : Nat | r == foldr (+) 0 xs |)

-- string append
+s+ : (x : String) -> (y : String) -> (| z : String | z == (toList x) ++ (toList y)|)

splitOn : (x : String) -> (sep : Char) -> (| gr : List String | length gr - 1 == number of sep in x |)

-- we can only validate the contract at the start & end
foldr : (inv : Contract B) -> (f : A -> B -> B) -> (| a : B | inv a |) -> List A -> (| r : B | inv r |)
foldr inv = ..

nub : (xs : List A) -> (| ys : List A | all (1 _==_ . length) (group ys) |)


sort : (xs : List A) -> (| ys : List A | isSorted ys |)

insert : (| xs : List A | isSorted xs |) -> (x : A) -> (| ys : List A | isSorted ys && x elem ys)


-----------------------------------------------------

insert1 : (xs : List A) -> (xs_p : Sorted xs) -> (x : A) -> (| ys : List A | isSorted ys && x elem ys)
insert1 = mkForeign (HSFun "hsinsert" [HSList A, A] (HSList A))

-- external interface
insert : (xs : SortedList A) -> (x : A) -> (ys : SortedList A ** x elem ys)
insert ..

-- If we only talk about calling HS through the FFI. Does it ever occur that we need
-- to establish the preconditions using contracts?
-- This can potentially occur with higher-order functions, when we want to validate the input
-- from the HS function. eg.:

foldr = HS function

sum xs = foldr (\a b -> || a elem xs || a agda_+_ b) 0 xs


---------------------------------------------------------
Higher Order Contracts
---------------------------------------------------------
Use case: callbacks / continuation passing
          e.g. GUIs, Iteratees, CPS
Tricky part: Contracts would often depend on the real world, but we don't want IO contracts. Might also be racy.

-- HS defs
data ListView a = ... items :: IORef [a] ....

onListItemSelected :: ListView a -> (ListIndex -> IO ()) -> IO ()
onListItemSelected' :: (lst : ListView a) -> ( {x : ListIndex | x in (getItems lst) } -> IO ()) -> IO ()
-- or simpler, index >= 0. getItems is in IO, so how would that work?

-- assume we use OpenGL, and convert mouse coordinates to ([0;1], [0;1]). Then we could specify a contract for that.
-- If we would use pixel-coordinates, we would need to know the size of the surface. This would probably be in IO as well..
setMouseHandler :: ((Double, Double) -> IO ()) -> IO ()
setMouseHandler :: ({ (x : Double, y : Double) | x,y in [0..1] } -> IO ()) -> IO ()


(actually, IO in contracts shouldn't be that much of a problem, assuming the result of a function is in IO. Then we can just do this
for the list example:
do
    items <- getItems
    assert (index in items)
    DoSomething..
)

Actually, this means we can also use asserts to check the current state.
do
    setWindowSize w
    w' <- getWindowSize
    assert w == w'

----------------------------------------------------------
Evaluation
----------------------------------------------------------
As we assume that we are in a lazy language, contracts are only
checked if the body is evaluated.

Should a failed contract call error? Or should we have some special
support for a MonadFail or MonadContract, where the user can specify the
behaviour on error? For FFI calls, just crashing should be okay.
